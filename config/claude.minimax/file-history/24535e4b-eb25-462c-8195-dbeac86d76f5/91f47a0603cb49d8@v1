/**
 * Canonical Type System Tests
 *
 * Tests for the 5-axis type system as specified in:
 * design-docs/spec/CANONICAL-ARCHITECTURE-oscilla-v2.5-20260109-160000.md
 */

import { describe, it, expect } from 'vitest';
import {
  // PayloadType
  type PayloadType,

  // AxisTag
  type AxisTag,
  axisDefault,
  axisInstantiated,
  isInstantiated,
  getAxisValue,

  // Cardinality
  type Cardinality,
  cardinalityZero,
  cardinalityOne,
  cardinalityMany,

  // Temporality
  type Temporality,
  temporalityContinuous,
  temporalityDiscrete,

  // Binding
  type Binding,
  bindingUnbound,
  bindingWeak,
  bindingStrong,
  bindingIdentity,
  referentRef,

  // Extent
  type Extent,
  extentDefault,
  extent,

  // CanonicalType
  type CanonicalType,
  canonicalType,

  // Defaults
  DEFAULTS_V0,
  FRAME_V0,

  // Instance system
  instanceRef,

  // Unification
  unifyAxis,
  unifyExtent,
  AxisUnificationError,

  // Derived types
  signalTypeSignal,
  signalTypeField,
  signalTypeTrigger,
  signalTypeStatic,

  // Event types
  eventType,
  eventTypeScalar,
  eventTypePerInstance,
  isPayloadVar,
} from '../canonical-types';
import { FLOAT, INT, BOOL, VEC2, VEC3, COLOR, SHAPE, CAMERA_PROJECTION } from '../canonical-types';
import { instanceId } from '../../compiler/ir/Indices';

// =============================================================================
// PayloadType Tests
// =============================================================================

describe('PayloadType', () => {
  it('includes all core payload types', () => {
    const payloads: PayloadType[] = [FLOAT, INT, VEC2, COLOR, BOOL, SHAPE];
    expect(payloads.length).toBe(6);
  });

  it('does NOT include event or domain (these are axis concepts)', () => {
    // TypeScript will catch this at compile time, but documenting intent
    const validPayloads: PayloadType[] = [FLOAT, INT, VEC2, COLOR, BOOL, SHAPE];
    expect(validPayloads).not.toContain('event');
    expect(validPayloads).not.toContain('domain');
  });
});

// =============================================================================
// AxisTag Tests
// =============================================================================

describe('AxisTag', () => {
  describe('construction', () => {
    it('creates a default tag', () => {
      const tag = axisDefault<Cardinality>();
      expect(tag.kind).toBe('default');
    });

    it('creates an instantiated tag with value', () => {
      const tag = axisInstantiated(cardinalityOne());
      expect(tag.kind).toBe('instantiated');
      if (tag.kind === 'instantiated') {
        expect(tag.value.kind).toBe('one');
      }
    });
  });

  describe('type narrowing', () => {
    it('isInstantiated returns true for instantiated tags', () => {
      const tag = axisInstantiated(cardinalityOne());
      expect(isInstantiated(tag)).toBe(true);
    });

    it('isInstantiated returns false for default tags', () => {
      const tag = axisDefault<Cardinality>();
      expect(isInstantiated(tag)).toBe(false);
    });

    it('type narrows correctly after isInstantiated check', () => {
      const tag: AxisTag<Cardinality> = axisInstantiated(cardinalityOne());
      if (isInstantiated(tag)) {
        // TypeScript should know tag.value exists here
        expect(tag.value.kind).toBe('one');
      }
    });
  });

  describe('getAxisValue', () => {
    it('returns value for instantiated tag', () => {
      const tag = axisInstantiated(cardinalityOne());
      const value = getAxisValue(tag, cardinalityZero());
      expect(value.kind).toBe('one');
    });

    it('returns default for default tag', () => {
      const tag = axisDefault<Cardinality>();
      const value = getAxisValue(tag, cardinalityZero());
      expect(value.kind).toBe('zero');
    });
  });
});

// =============================================================================
// Cardinality Tests
// =============================================================================

describe('Cardinality', () => {
  it('creates zero cardinality', () => {
    const c = cardinalityZero();
    expect(c.kind).toBe('zero');
  });

  it('creates one cardinality', () => {
    const c = cardinalityOne();
    expect(c.kind).toBe('one');
  });

  it('creates many cardinality with instance reference', () => {
    const c = cardinalityMany(instanceRef('circle', 'circles-1'));
    expect(c.kind).toBe('many');
    if (c.kind === 'many') {
      expect(c.instance.kind).toBe('instance');
      expect(c.instance.domainType).toBe('circle');
      expect(c.instance.instanceId).toBe('circles-1');
    }
  });
});

// =============================================================================
// Temporality Tests
// =============================================================================

describe('Temporality', () => {
  it('creates continuous temporality', () => {
    const t = temporalityContinuous();
    expect(t.kind).toBe('continuous');
  });

  it('creates discrete temporality', () => {
    const t = temporalityDiscrete();
    expect(t.kind).toBe('discrete');
  });
});

// =============================================================================
// Binding Tests
// =============================================================================

describe('Binding', () => {
  it('creates unbound binding', () => {
    const b = bindingUnbound();
    expect(b.kind).toBe('unbound');
  });

  it('creates weak binding with referent', () => {
    const b = bindingWeak(referentRef('ref1'));
    expect(b.kind).toBe('weak');
    if (b.kind === 'weak') {
      expect(b.referent.id).toBe('ref1');
    }
  });

  it('creates strong binding with referent', () => {
    const b = bindingStrong(referentRef('ref2'));
    expect(b.kind).toBe('strong');
    if (b.kind === 'strong') {
      expect(b.referent.id).toBe('ref2');
    }
  });

  it('creates identity binding with referent', () => {
    const b = bindingIdentity(referentRef('ref3'));
    expect(b.kind).toBe('identity');
    if (b.kind === 'identity') {
      expect(b.referent.id).toBe('ref3');
    }
  });
});

// =============================================================================
// Extent Tests
// =============================================================================

describe('Extent', () => {
  it('creates default extent with all default axes', () => {
    const e = extentDefault();
    expect(e.cardinality.kind).toBe('default');
    expect(e.temporality.kind).toBe('default');
    expect(e.binding.kind).toBe('default');
    expect(e.perspective.kind).toBe('default');
    expect(e.branch.kind).toBe('default');
  });

  it('creates extent with partial overrides', () => {
    const e = extent({
      cardinality: axisInstantiated(cardinalityOne()),
    });
    expect(e.cardinality.kind).toBe('instantiated');
    expect(e.temporality.kind).toBe('default');
    expect(e.binding.kind).toBe('default');
  });
});

// =============================================================================
// CanonicalType Tests
// =============================================================================

describe('CanonicalType', () => {
  it('creates CanonicalType with payload and default extent', () => {
    const st = canonicalType(FLOAT);
    expect(st.payload.kind).toBe('float');
    expect(st.extent.cardinality.kind).toBe('default');
  });

  it('creates CanonicalType with payload and custom extent', () => {
    const st = canonicalType(VEC2, {
      cardinality: axisInstantiated(cardinalityMany(instanceRef('shape', 'grid-1'))),
    });
    expect(st.payload.kind).toBe('vec2');
    expect(st.extent.cardinality.kind).toBe('instantiated');
  });
});

// =============================================================================
// DEFAULTS_V0 Tests
// =============================================================================

describe('DEFAULTS_V0', () => {
  it('has cardinality = one', () => {
    expect(DEFAULTS_V0.cardinality.kind).toBe('one');
  });

  it('has temporality = continuous', () => {
    expect(DEFAULTS_V0.temporality.kind).toBe('continuous');
  });

  it('has binding = unbound', () => {
    expect(DEFAULTS_V0.binding.kind).toBe('unbound');
  });

  it('has perspective = global', () => {
    expect(DEFAULTS_V0.perspective).toBe('global');
  });

  it('has branch = main', () => {
    expect(DEFAULTS_V0.branch).toBe('main');
  });
});

describe('FRAME_V0', () => {
  it('has perspective = global', () => {
    expect(FRAME_V0.perspective).toBe('global');
  });

  it('has branch = main', () => {
    expect(FRAME_V0.branch).toBe('main');
  });
});

// =============================================================================
// Axis Unification Tests
// =============================================================================

describe('unifyAxis', () => {
  describe('strict join rules (Section 3.5.3)', () => {
    it('default + default → default', () => {
      const a = axisDefault<Cardinality>();
      const b = axisDefault<Cardinality>();
      const result = unifyAxis('cardinality', a, b);
      expect(result.kind).toBe('default');
    });

    it('default + instantiated(X) → instantiated(X)', () => {
      const a = axisDefault<Cardinality>();
      const b = axisInstantiated(cardinalityOne());
      const result = unifyAxis('cardinality', a, b);
      expect(result.kind).toBe('instantiated');
      if (result.kind === 'instantiated') {
        expect(result.value.kind).toBe('one');
      }
    });

    it('instantiated(X) + default → instantiated(X)', () => {
      const a = axisInstantiated(cardinalityOne());
      const b = axisDefault<Cardinality>();
      const result = unifyAxis('cardinality', a, b);
      expect(result.kind).toBe('instantiated');
      if (result.kind === 'instantiated') {
        expect(result.value.kind).toBe('one');
      }
    });

    it('instantiated(X) + instantiated(X) → instantiated(X)', () => {
      const a = axisInstantiated(cardinalityOne());
      const b = axisInstantiated(cardinalityOne());
      const result = unifyAxis('cardinality', a, b);
      expect(result.kind).toBe('instantiated');
      if (result.kind === 'instantiated') {
        expect(result.value.kind).toBe('one');
      }
    });

    it('instantiated(X) + instantiated(Y), X≠Y → ERROR', () => {
      const a = axisInstantiated(cardinalityOne());
      const b = axisInstantiated(cardinalityZero());
      expect(() => unifyAxis('cardinality', a, b)).toThrow(AxisUnificationError);
    });
  });

  describe('complex value equality', () => {
    it('unifies matching many(instance) cardinalities', () => {
      const a = axisInstantiated(cardinalityMany(instanceRef('circle', 'inst-1')));
      const b = axisInstantiated(cardinalityMany(instanceRef('circle', 'inst-1')));
      const result = unifyAxis('cardinality', a, b);
      expect(result.kind).toBe('instantiated');
    });

    it('rejects mismatched instance references', () => {
      const a = axisInstantiated(cardinalityMany(instanceRef('circle', 'inst-1')));
      const b = axisInstantiated(cardinalityMany(instanceRef('circle', 'inst-2')));
      expect(() => unifyAxis('cardinality', a, b)).toThrow(AxisUnificationError);
    });
  });
});

describe('unifyExtent', () => {
  it('unifies two default extents', () => {
    const a = extentDefault();
    const b = extentDefault();
    const result = unifyExtent(a, b);
    expect(result.cardinality.kind).toBe('default');
    expect(result.temporality.kind).toBe('default');
  });

  it('propagates instantiated values', () => {
    const a = extent({ cardinality: axisInstantiated(cardinalityOne()) });
    const b = extent({ temporality: axisInstantiated(temporalityDiscrete()) });
    const result = unifyExtent(a, b);
    expect(result.cardinality.kind).toBe('instantiated');
    expect(result.temporality.kind).toBe('instantiated');
  });

  it('throws on axis mismatch', () => {
    const a = extent({ cardinality: axisInstantiated(cardinalityOne()) });
    const b = extent({ cardinality: axisInstantiated(cardinalityZero()) });
    expect(() => unifyExtent(a, b)).toThrow(AxisUnificationError);
  });
});

// =============================================================================
// Derived CanonicalType Helpers Tests
// =============================================================================

describe('derived CanonicalType helpers', () => {
  it('signalTypeSignal creates one + continuous', () => {
    const st = signalTypeSignal(FLOAT);
    expect(st.payload.kind).toBe('float');
    const card = st.extent.cardinality;
    const temp = st.extent.temporality;
    expect(card.kind).toBe('instantiated');
    expect(temp.kind).toBe('instantiated');
    if (card.kind === 'instantiated' && temp.kind === 'instantiated') {
      expect(card.value.kind).toBe('one');
      expect(temp.value.kind).toBe('continuous');
    }
  });

  it('signalTypeField creates many + continuous', () => {
    const st = signalTypeField(VEC2, 'grid-1');
    expect(st.payload.kind).toBe('vec2');
    const card = st.extent.cardinality;
    const temp = st.extent.temporality;
    expect(card.kind).toBe('instantiated');
    expect(temp.kind).toBe('instantiated');
    if (card.kind === 'instantiated' && temp.kind === 'instantiated') {
      expect(card.value.kind).toBe('many');
      expect(temp.value.kind).toBe('continuous');
    }
  });

  it('signalTypeTrigger creates one + discrete', () => {
    const st = signalTypeTrigger(BOOL);
    const card = st.extent.cardinality;
    const temp = st.extent.temporality;
    expect(card.kind).toBe('instantiated');
    expect(temp.kind).toBe('instantiated');
    if (card.kind === 'instantiated' && temp.kind === 'instantiated') {
      expect(card.value.kind).toBe('one');
      expect(temp.value.kind).toBe('discrete');
    }
  });

  it('signalTypeStatic creates zero + continuous', () => {
    const st = signalTypeStatic(INT);
    const card = st.extent.cardinality;
    const temp = st.extent.temporality;
    expect(card.kind).toBe('instantiated');
    expect(temp.kind).toBe('instantiated');
    if (card.kind === 'instantiated' && temp.kind === 'instantiated') {
      expect(card.value.kind).toBe('zero');
      expect(temp.value.kind).toBe('continuous');
    }
  });
});

// =============================================================================
// EventExpr Type Invariants
// =============================================================================

describe('EventExpr Type Invariants', () => {
  it('eventTypeScalar creates valid event type (one + discrete)', () => {
    const type = eventTypeScalar();

    // Hard invariant: payload must be bool
    expect(type.payload.kind).toBe('bool');
    expect(isConcretePayload(type.payload) ? type.payload.stride : 1).toBe(1);

    // Hard invariant: unit must be none
    expect(type.unit.kind).toBe('none');

    // Hard invariant: temporality must be discrete
    expect(type.extent.temporality.kind).toBe('instantiated');
    if (type.extent.temporality.kind === 'instantiated') {
      expect(type.extent.temporality.value.kind).toBe('discrete');
    }

    // Cardinality should be 'one' for scalar events
    expect(type.extent.cardinality.kind).toBe('instantiated');
    if (type.extent.cardinality.kind === 'instantiated') {
      expect(type.extent.cardinality.value.kind).toBe('one');
    }

    // Other axes should be default
    expect(type.extent.binding.kind).toBe('default');
    expect(type.extent.perspective.kind).toBe('default');
    expect(type.extent.branch.kind).toBe('default');
  });

  it('eventTypePerInstance creates valid event type (many + discrete)', () => {
    const ref = instanceRef('circle', 'test-instance');
    const type = eventTypePerInstance(ref);

    // Hard invariant: payload must be bool
    expect(type.payload.kind).toBe('bool');
    expect(isConcretePayload(type.payload) ? type.payload.stride : 1).toBe(1);

    // Hard invariant: unit must be none
    expect(type.unit.kind).toBe('none');

    // Hard invariant: temporality must be discrete
    expect(type.extent.temporality.kind).toBe('instantiated');
    if (type.extent.temporality.kind === 'instantiated') {
      expect(type.extent.temporality.value.kind).toBe('discrete');
    }

    // Cardinality should be 'many' for per-instance events
    expect(type.extent.cardinality.kind).toBe('instantiated');
    if (type.extent.cardinality.kind === 'instantiated') {
      expect(type.extent.cardinality.value.kind).toBe('many');
      if (type.extent.cardinality.value.kind === 'many') {
        expect(type.extent.cardinality.value.instance.instanceId).toBe('test-instance');
        expect(type.extent.cardinality.value.instance.domainType).toBe('circle');
      }
    }
  });

  it('eventType accepts custom cardinality axis', () => {
    const customCard: CardinalityAxis = {
      kind: 'instantiated',
      value: { kind: 'one' }
    };
    const type = eventType(customCard);

    expect(type.payload.kind).toBe('bool');
    expect(type.unit.kind).toBe('none');
    expect(type.extent.temporality.kind).toBe('instantiated');
    if (type.extent.temporality.kind === 'instantiated') {
      expect(type.extent.temporality.value.kind).toBe('discrete');
    }
  });
});
