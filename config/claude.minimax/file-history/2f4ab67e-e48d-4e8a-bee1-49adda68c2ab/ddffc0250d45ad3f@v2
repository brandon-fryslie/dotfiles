/**
 * IRBuilder Implementation
 *
 * Concrete implementation of the IRBuilder interface.
 */

import type { CanonicalType } from '../../core/canonical-types';
import { FLOAT, INT, BOOL, VEC2, VEC3, COLOR, SHAPE, CAMERA_PROJECTION, canonicalType, unitScalar } from '../../core/canonical-types';
import type { TopologyId } from '../../shapes/types';
import type { IRBuilder } from './IRBuilder';
import type {
  SigExprId,
  FieldExprId,
  EventExprId,
  EventSlotId,
  ValueSlot,
  StateId,
  StateSlotId,
  InstanceId,
  DomainTypeId,
} from './Indices';
import {
  sigExprId,
  fieldExprId,
  eventExprId,
  eventSlotId,
  valueSlot,
  stateId,
  stateSlotId,
  instanceId,
} from './Indices';
import type { TimeModelIR } from './schedule';
import type {
  PureFn,
  OpCode,
  SigExpr,
  FieldExpr,
  EventExpr,
  InstanceDecl,
  Step,
  IntrinsicPropertyName,
  PlacementFieldName,
  BasisKind,
  ContinuityPolicy,
  StableStateId,
  StateMapping,
} from './types';
import type { CameraDeclIR } from './program';

// =============================================================================
// IRBuilderImpl
// =============================================================================

export class IRBuilderImpl implements IRBuilder {
  private sigExprs: SigExpr[] = [];
  private fieldExprs: FieldExpr[] = [];
  private eventExprs: EventExpr[] = [];
  private instances: Map<InstanceId, InstanceDecl> = new Map(); // NEW
  private slotCounter = 0;
  private stateCounter = 0;
  private stateSlotCounter = 0;
  private constCounter = 0;
  private timeModel: TimeModelIR | undefined;
  private currentBlockId: string | undefined;

  // Hash-consing caches for expression deduplication (I13)
  private sigExprCache = new Map<string, SigExprId>();
  private fieldExprCache = new Map<string, FieldExprId>();
  private eventExprCache = new Map<string, EventExprId>();

  // Slot registrations for debug/validation
  private sigSlots = new Map<number, ValueSlot>();
  private fieldSlots = new Map<number, ValueSlot>();
  private eventSlots = new Map<EventExprId, EventSlotId>();
  private eventSlotCounter = 0;

  // Slot type tracking for slotMeta generation
  private slotTypes = new Map<ValueSlot, CanonicalType>();

  constructor() {
    // Reserve system slots at fixed positions (compiler-runtime contract)
    // Slot 0: time.palette (color, stride=4)
    this.reserveSystemSlot(0, canonicalType(COLOR));
  }

  /**
   * Reserve a system slot at a fixed position with known type.
   * Used for compiler-runtime contracts like time.palette at slot 0.
   */
  private reserveSystemSlot(slotId: number, type: CanonicalType): void {
    const slot = slotId as ValueSlot;
    this.slotTypes.set(slot, type);
    // Ensure slotCounter is past reserved slots
    if (this.slotCounter <= slotId) {
      this.slotCounter = slotId + 1;
    }
  }

  // State slot tracking for persistent cross-frame storage
  // OLD: private stateSlots: { initialValue: number }[] = [];
  // NEW: Store state mappings with stable IDs
  private stateMappings: StateMapping[] = [];

  // Step tracking for schedule generation
  private steps: Step[] = [];

  // Render globals tracking (Camera system)
  private renderGlobals: CameraDeclIR[] = [];

  // =========================================================================
  // Signal Expressions
  // =========================================================================

  sigConst(value: number | string | boolean, type: CanonicalType): SigExprId {
    // Hash-consing (I13): check cache before creating new ID
    const expr = { kind: 'const' as const, value, type };
    const hash = hashSigExpr(expr);
    const existing = this.sigExprCache.get(hash);
    if (existing !== undefined) {
      return existing;
    }
    const id = sigExprId(this.sigExprs.length);
    this.sigExprs.push(expr);
    this.sigExprCache.set(hash, id);
    return id;
  }

  sigSlot(slot: ValueSlot, type: CanonicalType): SigExprId {
    const expr = { kind: 'slot' as const, slot, type };
    const hash = hashSigExpr(expr);
    const existing = this.sigExprCache.get(hash);
    if (existing !== undefined) {
      return existing;
    }
    const id = sigExprId(this.sigExprs.length);
    this.sigExprs.push(expr);
    this.sigExprCache.set(hash, id);
    return id;
  }

  sigTime(which: 'tMs' | 'phaseA' | 'phaseB' | 'dt' | 'progress' | 'palette' | 'energy', type: CanonicalType): SigExprId {
    const expr = { kind: 'time' as const, which, type };
    const hash = hashSigExpr(expr);
    const existing = this.sigExprCache.get(hash);
    if (existing !== undefined) {
      return existing;
    }
    const id = sigExprId(this.sigExprs.length);
    this.sigExprs.push(expr);
    this.sigExprCache.set(hash, id);
    return id;
  }

  sigExternal(channel: string, type: CanonicalType): SigExprId {
    const expr = { kind: 'external' as const, which: channel, type };
    const hash = hashSigExpr(expr);
    const existing = this.sigExprCache.get(hash);
    if (existing !== undefined) {
      return existing;
    }
    const id = sigExprId(this.sigExprs.length);
    this.sigExprs.push(expr);
    this.sigExprCache.set(hash, id);
    return id;
  }

  sigMap(input: SigExprId, fn: PureFn, type: CanonicalType): SigExprId {
    const expr = { kind: 'map' as const, input, fn, type };
    const hash = hashSigExpr(expr);
    const existing = this.sigExprCache.get(hash);
    if (existing !== undefined) {
      return existing;
    }
    const id = sigExprId(this.sigExprs.length);
    this.sigExprs.push(expr);
    this.sigExprCache.set(hash, id);
    return id;
  }

  sigZip(inputs: readonly SigExprId[], fn: PureFn, type: CanonicalType): SigExprId {
    const expr = { kind: 'zip' as const, inputs, fn, type };
    const hash = hashSigExpr(expr);
    const existing = this.sigExprCache.get(hash);
    if (existing !== undefined) {
      return existing;
    }
    const id = sigExprId(this.sigExprs.length);
    this.sigExprs.push(expr);
    this.sigExprCache.set(hash, id);
    return id;
  }
  sigShapeRef(topologyId: TopologyId, paramSignals: readonly SigExprId[], type: CanonicalType, controlPointField?: { id: FieldExprId; stride: number }): SigExprId {
    const expr = { kind: 'shapeRef' as const, topologyId, paramSignals, controlPointField, type };
    const hash = hashSigExpr(expr);
    const existing = this.sigExprCache.get(hash);
    if (existing !== undefined) {
      return existing;
    }
    const id = sigExprId(this.sigExprs.length);
    this.sigExprs.push(expr);
    this.sigExprCache.set(hash, id);
    return id;
  }

  /**
   * Binary operation helper - creates a sig expression that zips two inputs with an opcode.
   */
  sigBinOp(a: SigExprId, b: SigExprId, opcode: OpCode, type: CanonicalType): SigExprId {
    return this.sigZip([a, b], { kind: 'opcode', opcode }, type);
  }

  /**
   * Unary operation helper - creates a sig expression that maps a single input with an opcode.
   */
  sigUnaryOp(input: SigExprId, opcode: OpCode, type: CanonicalType): SigExprId {
    return this.sigMap(input, { kind: 'opcode', opcode }, type);
  }

  // =========================================================================
  // Signal Combine
  // =========================================================================

  sigCombine(
    inputs: readonly SigExprId[],
    mode: 'sum' | 'average' | 'max' | 'min' | 'last',
    type: CanonicalType
  ): SigExprId {
    // For combining signals, we use zip with appropriate combine function
    const fn: PureFn = { kind: 'kernel', name: `combine_${mode}` };
    const expr = { kind: 'zip' as const, inputs, fn, type };
    const hash = hashSigExpr(expr);
    const existing = this.sigExprCache.get(hash);
    if (existing !== undefined) {
      return existing;
    }
    const id = sigExprId(this.sigExprs.length);
    this.sigExprs.push(expr);
    this.sigExprCache.set(hash, id);
    return id;
  }

  // =========================================================================
  // Signal Expression Lookup
  // =========================================================================

  /**
   * Look up the SigExpr for a given SigExprId.
   * Used by blocks that need to introspect expression structure.
   */
  getSigExpr(id: SigExprId): SigExpr | undefined {
    return this.sigExprs[id as number];
  }

  /**
   * Look up the type for a signal expression.
   */
  getSigExprType(id: SigExprId): CanonicalType | undefined {
    const expr = this.sigExprs[id as number];
    return expr?.type;
  }

  /**
   * Resolve a SigExprId to its slot, if it exists.
   * Returns undefined if the signal is not a slot reference.
   */
  resolveSigSlot(id: SigExprId): ValueSlot | undefined {
    const expr = this.sigExprs[id as number];
    if (expr?.kind === 'slot') {
      return expr.slot as unknown as ValueSlot;
    }
    return undefined;
  }

  // =========================================================================
  // Field Expressions
  // =========================================================================

  fieldConst(value: number | string, type: CanonicalType): FieldExprId {
    const expr = { kind: 'const' as const, value, type };
    const hash = hashFieldExpr(expr);
    const existing = this.fieldExprCache.get(hash);
    if (existing !== undefined) {
      return existing;
    }
    const id = fieldExprId(this.fieldExprs.length);
    this.fieldExprs.push(expr);
    this.fieldExprCache.set(hash, id);
    return id;
  }

  /**
   * Create a field from an intrinsic property.
   * Uses proper FieldExprIntrinsic type - no 'as any' casts needed.
   */
  fieldIntrinsic(instanceId: InstanceId, intrinsic: IntrinsicPropertyName, type: CanonicalType): FieldExprId {
    const expr = {
      kind: 'intrinsic' as const,
      instanceId,
      intrinsic,
      type,
    };
    const hash = hashFieldExpr(expr);
    const existing = this.fieldExprCache.get(hash);
    if (existing !== undefined) {
      return existing;
    }
    const id = fieldExprId(this.fieldExprs.length);
    this.fieldExprs.push(expr);
    this.fieldExprCache.set(hash, id);
    return id;
  }


  /**
   * Create a field from placement basis.
   * Replaces normalizedIndex for gauge-invariant layouts.
   */
  fieldPlacement(
    instanceId: InstanceId,
    field: PlacementFieldName,
    basisKind: BasisKind,
    type: CanonicalType
  ): FieldExprId {
    if (!instanceId) {
      throw new Error('fieldPlacement: instanceId is required');
    }
    if (!field) {
      throw new Error('fieldPlacement: field is required');
    }
    if (!basisKind) {
      throw new Error('fieldPlacement: basisKind is required');
    }
    if (!type) {
      throw new Error('fieldPlacement: type is required');
    }

    const expr = {
      kind: 'placement' as const,
      instanceId,
      field,
      basisKind,
      type,
    };
    const hash = hashFieldExpr(expr);
    const existing = this.fieldExprCache.get(hash);
    if (existing !== undefined) {
      return existing;
    }
    const id = fieldExprId(this.fieldExprs.length);
    this.fieldExprs.push(expr);
    this.fieldExprCache.set(hash, id);
    return id;
  }

  Broadcast(signal: SigExprId, type: CanonicalType): FieldExprId {
    const expr = { kind: 'broadcast' as const, signal, type };
    const hash = hashFieldExpr(expr);
    const existing = this.fieldExprCache.get(hash);
    if (existing !== undefined) {
      return existing;
    }
    const id = fieldExprId(this.fieldExprs.length);
    this.fieldExprs.push(expr);
    this.fieldExprCache.set(hash, id);
    return id;
  }

  ReduceField(field: FieldExprId, op: 'min' | 'max' | 'sum' | 'avg', type: CanonicalType): SigExprId {
    const expr = { kind: 'reduceField' as const, field, op, type };
    const hash = hashSigExpr(expr);
    const existing = this.sigExprCache.get(hash);
    if (existing !== undefined) {
      return existing;
    }
    const id = sigExprId(this.sigExprs.length);
    this.sigExprs.push(expr);
    this.sigExprCache.set(hash, id);
    return id;
  }

  fieldMap(input: FieldExprId, fn: PureFn, type: CanonicalType): FieldExprId {
    const instanceId = this.inferFieldInstance(input);
    const expr = { kind: 'map' as const, input, fn, type, instanceId };
    const hash = hashFieldExpr(expr);
    const existing = this.fieldExprCache.get(hash);
    if (existing !== undefined) {
      return existing;
    }
    const id = fieldExprId(this.fieldExprs.length);
    this.fieldExprs.push(expr);
    this.fieldExprCache.set(hash, id);
    return id;
  }

  fieldZip(inputs: readonly FieldExprId[], fn: PureFn, type: CanonicalType): FieldExprId {
    const instanceId = this.inferZipInstance(inputs);
    const expr = { kind: 'zip' as const, inputs, fn, type, instanceId };
    const hash = hashFieldExpr(expr);
    const existing = this.fieldExprCache.get(hash);
    if (existing !== undefined) {
      return existing;
    }
    const id = fieldExprId(this.fieldExprs.length);
    this.fieldExprs.push(expr);
    this.fieldExprCache.set(hash, id);
    return id;
  }

  fieldZipSig(
    field: FieldExprId,
    signals: readonly SigExprId[],
    fn: PureFn,
    type: CanonicalType
  ): FieldExprId {
    const instanceId = this.inferFieldInstance(field);
    const expr = { kind: 'zipSig' as const, field, signals, fn, type, instanceId };
    const hash = hashFieldExpr(expr);
    const existing = this.fieldExprCache.get(hash);
    if (existing !== undefined) {
      return existing;
    }
    const id = fieldExprId(this.fieldExprs.length);
    this.fieldExprs.push(expr);
    this.fieldExprCache.set(hash, id);
    return id;
  }

  fieldPathDerivative(
    input: FieldExprId,
    operation: 'tangent' | 'arcLength',
    type: CanonicalType
  ): FieldExprId {
    const expr = { kind: 'pathDerivative' as const, input, operation, type };
    const hash = hashFieldExpr(expr);
    const existing = this.fieldExprCache.get(hash);
    if (existing !== undefined) {
      return existing;
    }
    const id = fieldExprId(this.fieldExprs.length);
    this.fieldExprs.push(expr);
    this.fieldExprCache.set(hash, id);
    return id;
  }

  // =========================================================================
  // Instance Inference
  // =========================================================================

  /**
   * Infer the instance a field expression operates over.
   * Returns the InstanceId if the field is bound to a specific instance,
   * or undefined if the field is instance-agnostic (const, broadcast).
   *
   * Instance binding:
   * - intrinsic, array, stateRead → return their instanceId (bound to instance)
   * - map, zipSig → propagate from input
   * - zip → unify from inputs (must all be same instance)
   * - const, broadcast → undefined (instance-agnostic)
   */
  inferFieldInstance(fieldId: FieldExprId): InstanceId | undefined {
    const expr = this.fieldExprs[fieldId as number];
    if (!expr) return undefined;

    switch (expr.kind) {
      case 'intrinsic':
      case 'stateRead':
      case 'placement':
        return expr.instanceId; // These ARE bound to an instance
      case 'map':
        return expr.instanceId ?? this.inferFieldInstance(expr.input);
      case 'zip':
        return expr.instanceId ?? this.inferZipInstance(expr.inputs);
      case 'zipSig':
        return expr.instanceId ?? this.inferFieldInstance(expr.field);
      case 'pathDerivative':
        return this.inferFieldInstance(expr.input);
      case 'broadcast':
      case 'const':
        return undefined; // Truly instance-agnostic
    }
  }

  /**
   * Infer instance from zip inputs, throwing an error if they differ.
   * Returns the unified instance, or undefined if all inputs are instance-agnostic.
   */
  private inferZipInstance(inputs: readonly FieldExprId[]): InstanceId | undefined {
    const instances: InstanceId[] = [];
    for (const id of inputs) {
      const inst = this.inferFieldInstance(id);
      if (inst !== undefined) {
        instances.push(inst);
      }
    }

    if (instances.length === 0) return undefined;

    const first = instances[0];
    for (let i = 1; i < instances.length; i++) {
      if (instances[i] !== first) {
        throw new Error(
          `Instance mismatch in fieldZip: '${first}' vs '${instances[i]}'. ` +
          `All field inputs must share the same instance.`
        );
      }
    }
    return first;
  }

  // =========================================================================
  // Field Combine
  // =========================================================================

  fieldCombine(
    inputs: readonly FieldExprId[],
    mode: 'sum' | 'average' | 'max' | 'min' | 'last' | 'product',
    type: CanonicalType
  ): FieldExprId {
    // For combining fields, we use zip with appropriate combine function
    const fn: PureFn = { kind: 'kernel', name: `combine_${mode}` };
    const expr = { kind: 'zip' as const, inputs, fn, type };
    const hash = hashFieldExpr(expr);
    const existing = this.fieldExprCache.get(hash);
    if (existing !== undefined) {
      return existing;
    }
    const id = fieldExprId(this.fieldExprs.length);
    this.fieldExprs.push(expr);
    this.fieldExprCache.set(hash, id);
    return id;
  }

  // =========================================================================
  // Event Expressions
  // =========================================================================

  eventPulse(source: 'InfiniteTimeRoot'): EventExprId {
    const expr = { kind: 'pulse' as const, source: 'timeRoot' as const };
    const hash = hashEventExpr(expr);
    const existing = this.eventExprCache.get(hash);
    if (existing !== undefined) {
      return existing;
    }
    const id = eventExprId(this.eventExprs.length);
    this.eventExprs.push(expr);
    this.eventExprCache.set(hash, id);
    return id;
  }

  eventWrap(signal: SigExprId): EventExprId {
    const expr = { kind: 'wrap' as const, signal };
    const hash = hashEventExpr(expr);
    const existing = this.eventExprCache.get(hash);
    if (existing !== undefined) {
      return existing;
    }
    const id = eventExprId(this.eventExprs.length);
    this.eventExprs.push(expr);
    this.eventExprCache.set(hash, id);
    return id;
  }

  eventCombine(
    events: readonly EventExprId[],
    mode: 'any' | 'all' | 'merge' | 'last',
    _type?: CanonicalType
  ): EventExprId {
    // Map 'merge' and 'last' to underlying event combine modes
    const underlyingMode = mode === 'merge' || mode === 'last' ? 'any' : mode;
    const expr = { kind: 'combine' as const, events, mode: underlyingMode as 'any' | 'all' };
    const hash = hashEventExpr(expr);
    const existing = this.eventExprCache.get(hash);
    if (existing !== undefined) {
      return existing;
    }
    const id = eventExprId(this.eventExprs.length);
    this.eventExprs.push(expr);
    this.eventExprCache.set(hash, id);
    return id;
  }

  /**
   * Create a "never fires" event.
   * Used as a default when an event input is optional and not connected.
   */
  eventNever(): EventExprId {
    const expr = { kind: 'never' as const };
    const hash = hashEventExpr(expr);
    const existing = this.eventExprCache.get(hash);
    if (existing !== undefined) {
      return existing;
    }
    const id = eventExprId(this.eventExprs.length);
    this.eventExprs.push(expr);
    this.eventExprCache.set(hash, id);
    return id;
  }

  // =========================================================================
  // Domains (OLD - Will be removed in Sprint 8)
  // =========================================================================


  /**
   * Create a grid domain with rows x cols elements.
   */

  /**
   * Create an N-element domain with optional seed for deterministic IDs.
   */



  // =========================================================================
  // Instances (NEW)
  // =========================================================================

  /**
   * Create an instance (NEW).
   * Layout is now handled entirely through field kernels (circleLayout, lineLayout, gridLayout).
   */
  createInstance(
    domainType: DomainTypeId,
    count: number,
    lifecycle: 'static' | 'dynamic' | 'pooled' = 'static',
    identityMode: 'stable' | 'none' = 'stable',
    elementIdSeed?: number
  ): InstanceId {
    const id = instanceId(`instance_${this.instances.size}`);
    this.instances.set(id, {
      id: id as string,
      domainType: domainType as string,
      count,
      lifecycle,
      identityMode,
      elementIdSeed,
    });
    return id;
  }

  /**
   * Get all instances (NEW).
   */
  getInstances(): ReadonlyMap<InstanceId, InstanceDecl> {
    return this.instances;
  }

  /**
   * Generate a deterministic 8-char alphanumeric ID from a seed.
   */
  private seededId(seed: number): string {
    let h = seed;
    h = ((h >> 16) ^ h) * 0x45d9f3b;
    h = ((h >> 16) ^ h) * 0x45d9f3b;
    h = (h >> 16) ^ h;
    return Math.abs(h).toString(36).slice(0, 8).padStart(8, '0');
  }

  // =========================================================================
  // Slots
  // =========================================================================

  /**
   * P0: Strided slot allocation.
   *
   * Allocates a contiguous region of `stride` slots starting at a base slot.
   * Returns the base slot identifier.
   *
   * Contract:
   * - stride defaults to 1 (scalar slots)
   * - For multi-component payloads (vec2, vec3, color), stride > 1
   * - The slot allocator increments by stride to reserve the full region
   * - Downstream code reads/writes components at [slotBase+0 .. slotBase+(stride-1)]
   *
   * Example:
   *   vec2 slot: allocSlot(2) returns slotBase K, reserves slots [K, K+1]
   *   vec3 slot: allocSlot(3) returns slotBase K, reserves slots [K, K+1, K+2]
   *
   * @param stride - Number of contiguous f64 positions to allocate (default 1)
   * @returns Base slot identifier for the allocated region
   */
  allocSlot(stride: number = 1): ValueSlot {
    if (stride < 1 || !Number.isInteger(stride)) {
      throw new Error(`allocSlot: stride must be a positive integer, got ${stride}`);
    }
    const baseSlot = valueSlot(this.slotCounter);
    this.slotCounter += stride;
    return baseSlot;
  }

  /**
   * Allocate a typed value slot (tracking type for slotMeta generation).
   */
  allocTypedSlot(type: CanonicalType, _label?: string): ValueSlot {
    // Compute stride from payload
    let stride: number;
    switch (type.payload.kind) {
      case 'float':
      case 'int':
      case 'bool':
      case 'cameraProjection':
        stride = 1;
        break;
      case 'vec2':
        stride = 2;
        break;
      case 'vec3':
        stride = 3;
        break;
      case 'color':
        stride = 4;
        break;
      case 'shape':
        stride = 0; // Shape slots don't occupy f64 storage
        break;
      default:
        stride = 1; // Fallback
    }

    const slot = this.allocSlot(stride);
    this.slotTypes.set(slot, type);
    return slot;
  }
  /**
   * Register a slot type for slotMeta generation.
   *
   * CRITICAL: This must be called after lowering produces slots via allocSlot(stride).
   * Without type registration, slotMeta generation defaults to stride=1, causing runtime errors
   * when slotWriteStrided tries to write multiple components to a single-component slot.
   */
  registerSlotType(slot: ValueSlot, type: CanonicalType): void {
    this.slotTypes.set(slot, type);
  }

  getSlotCount(): number {
    return this.slotCounter;
  }

  /**
   * Get slot type information for slotMeta generation.
   */
  getSlotTypes(): ReadonlyMap<ValueSlot, CanonicalType> {
    return this.slotTypes;
  }

  /**
   * Get slot metadata inputs for slotMeta generation.
   *
   * This extracts all slots that have been allocated with type information,
   * computing stride from payload type. This is used at compile finalization
   * to ensure slotMeta covers all slots the runtime will touch.
   */
  getSlotMetaInputs(): ReadonlyMap<ValueSlot, { readonly type: CanonicalType; readonly stride: number }> {
    const result = new Map<ValueSlot, { readonly type: CanonicalType; readonly stride: number }>();
    for (const [slot, type] of this.slotTypes) {
      // Import payloadStride inline to compute stride from payload type
      let stride: number;
      switch (type.payload.kind) {
        case 'float':
        case 'int':
        case 'bool':
        case 'cameraProjection':
          stride = 1;
          break;
        case 'vec2':
          stride = 2;
          break;
        case 'vec3':
          stride = 3;
          break;
        case 'color':
          stride = 4;
          break;
        case 'shape':
          stride = 0;
          break;
        default:
          stride = 1; // Fallback
      }
      result.set(slot, { type, stride });
    }
    return result;
  }

  // =========================================================================
  // State Slots (Persistent Cross-Frame Storage)
  // =========================================================================

  allocStateSlot(
    stableId: StableStateId,
    options?: {
      initialValue?: number;
      stride?: number;
      instanceId?: InstanceId;
      laneCount?: number;
    }
  ): StateSlotId {
    const initialValue = options?.initialValue ?? 0;
    const stride = options?.stride ?? 1;
    const initial = Array(stride).fill(initialValue);

    const slotIndex = this.stateSlotCounter;

    if (options?.instanceId !== undefined) {
      // Field state (many cardinality)
      const laneCount = options.laneCount;
      if (laneCount === undefined) {
        throw new Error('allocStateSlot: laneCount required when instanceId is provided');
      }
      this.stateMappings.push({
        kind: 'field',
        stateId: stableId,
        instanceId: options.instanceId as string,
        slotStart: slotIndex,
        laneCount,
        stride,
        initial,
      });
      // Reserve slots for all lanes
      this.stateSlotCounter += laneCount * stride;
    } else {
      // Scalar state (signal cardinality)
      this.stateMappings.push({
        kind: 'scalar',
        stateId: stableId,
        slotIndex,
        stride,
        initial,
      });
      this.stateSlotCounter += stride;
    }

    return stateSlotId(slotIndex);
  }

  sigStateRead(stateSlot: StateSlotId, type: CanonicalType): SigExprId {
    const expr = { kind: 'stateRead' as const, stateSlot, type };
    const hash = hashSigExpr(expr);
    const existing = this.sigExprCache.get(hash);
    if (existing !== undefined) {
      return existing;
    }
    const id = sigExprId(this.sigExprs.length);
    this.sigExprs.push(expr);
    this.sigExprCache.set(hash, id);
    return id;
  }

  sigEventRead(eventSlot: EventSlotId, type: CanonicalType): SigExprId {
    // EventRead: produces a signal that is 1.0 on frames when the event fires, 0.0 otherwise
    const expr = { kind: 'eventRead' as const, eventSlot, type };
    const hash = hashSigExpr(expr);
    const existing = this.sigExprCache.get(hash);
    if (existing !== undefined) {
      return existing;
    }
    const id = sigExprId(this.sigExprs.length);
    this.sigExprs.push(expr);
    this.sigExprCache.set(hash, id);
    return id;
  }

  stepStateWrite(stateSlot: StateSlotId, value: SigExprId): void {
    this.steps.push({ kind: 'stateWrite', stateSlot, value });
  }

  fieldStateRead(stateSlot: StateSlotId, instanceId: InstanceId, type: CanonicalType): FieldExprId {
    const expr = { kind: 'stateRead' as const, stateSlot, instanceId, type };
    const hash = hashFieldExpr(expr);
    const existing = this.fieldExprCache.get(hash);
    if (existing !== undefined) {
      return existing;
    }
    const id = fieldExprId(this.fieldExprs.length);
    this.fieldExprs.push(expr);
    this.fieldExprCache.set(hash, id);
    return id;
  }

  stepFieldStateWrite(stateSlot: StateSlotId, value: FieldExprId): void {
    this.steps.push({ kind: 'fieldStateWrite', stateSlot, value });
  }

  stepEvalSig(expr: SigExprId, target: ValueSlot): void {
    this.steps.push({ kind: 'evalSig', expr, target });
  }

  /**
   * P3: Emit a strided slot write step.
   *
   * Writes multiple scalar signal components to contiguous slots.
   * This is the canonical way to materialize multi-component signal values (vec2, vec3, color)
   * without requiring array-returning evaluators or side-effect kernels.
   *
   * Contract:
   * - slotBase must have been allocated with allocSlot(stride=inputs.length)
   * - Each input is a scalar SigExprId
   * - At runtime, evaluates each input and writes to values.f64[slotBase+i]
   *
   * Example usage (vec2 output):
   *   const slotBase = builder.allocSlot(2);
   *   builder.stepSlotWriteStrided(slotBase, [sigExprX, sigExprY]);
   *
   * @param slotBase - Base slot for the contiguous write region
   * @param inputs - Array of scalar signal expressions to evaluate and write
   */
  stepSlotWriteStrided(slotBase: ValueSlot, inputs: readonly SigExprId[]): void {
    if (inputs.length === 0) {
      throw new Error('stepSlotWriteStrided: inputs array must not be empty');
    }
    this.steps.push({ kind: 'slotWriteStrided', slotBase, inputs });
  }

  stepMaterialize(field: FieldExprId, instanceId: InstanceId, target: ValueSlot): void {
    this.steps.push({ kind: 'materialize', field, instanceId: instanceId as string, target });
  }

  stepContinuityMapBuild(instanceId: InstanceId): void {
    // outputMapping key is derived from instanceId for consistency
    this.steps.push({ kind: 'continuityMapBuild', instanceId: instanceId as string, outputMapping: `mapping_${instanceId}` });
  }

  stepContinuityApply(
    targetKey: string,
    instanceId: InstanceId,
    policy: ContinuityPolicy,
    baseSlot: ValueSlot,
    outputSlot: ValueSlot,
    semantic: 'position' | 'radius' | 'opacity' | 'color' | 'custom',
    stride: number
  ): void {
    this.steps.push({
      kind: 'continuityApply',
      targetKey,
      instanceId: instanceId as string,
      policy,
      baseSlot,
      outputSlot,
      semantic,
      stride,
    });
  }

  // =========================================================================
  // Slot Registration
  // =========================================================================

  registerSigSlot(sigId: number, slot: ValueSlot): void {
    this.sigSlots.set(sigId, slot);
  }

  registerFieldSlot(fieldId: number, slot: ValueSlot): void {
    this.fieldSlots.set(fieldId, slot);
  }

  allocEventSlot(eventId: EventExprId): EventSlotId {
    const slot = eventSlotId(this.eventSlotCounter++);
    this.eventSlots.set(eventId, slot);
    return slot;
  }

  // =========================================================================
  // Render Globals
  // =========================================================================

  addRenderGlobal(decl: CameraDeclIR): void {
    this.renderGlobals.push(decl);
  }

  getRenderGlobals(): readonly CameraDeclIR[] {
    return this.renderGlobals;
  }

  // =========================================================================
  // State
  // =========================================================================

  allocState(_initialValue: unknown): StateId {
    return stateId(`state_${this.stateCounter++}`);
  }

  // =========================================================================
  // Debug Tracking
  // =========================================================================

  setCurrentBlockId(blockId: string | undefined): void {
    this.currentBlockId = blockId;
  }

  allocConstId(_value: number): number {
    return this.constCounter++;
  }

  // =========================================================================
  // Time Model
  // =========================================================================

  setTimeModel(model: TimeModelIR): void {
    this.timeModel = model;
  }

  getTimeModel(): TimeModelIR | undefined {
    return this.timeModel;
  }

  // =========================================================================
  // Pure Functions
  // =========================================================================

  opcode(op: OpCode): PureFn {
    return { kind: 'opcode', opcode: op };
  }

  expr(expression: string): PureFn {
    return { kind: 'expr', expr: expression };
  }

  kernel(name: string): PureFn {
    return { kind: 'kernel', name };
  }

  // =========================================================================
  // Build Result
  // =========================================================================

  getSigExprs(): readonly SigExpr[] {
    return this.sigExprs;
  }

  getFieldExprs(): readonly FieldExpr[] {
    return this.fieldExprs;
  }

  getEventExprs(): readonly EventExpr[] {
    return this.eventExprs;
  }

  getSigSlots(): ReadonlyMap<number, ValueSlot> {
    return this.sigSlots;
  }

  getFieldSlots(): ReadonlyMap<number, ValueSlot> {
    return this.fieldSlots;
  }

  getEventSlots(): ReadonlyMap<EventExprId, EventSlotId> {
    return this.eventSlots;
  }

  getEventSlotCount(): number {
    return this.eventSlotCounter;
  }

  /**
   * Get state mappings with stable IDs for hot-swap migration.
   */
  getStateMappings(): readonly StateMapping[] {
    return this.stateMappings;
  }


  getStateSlotCount(): number {
    return this.stateSlotCounter;
  }

  getSteps(): readonly Step[] {
    return this.steps;
  }

  getSchedule(): TimeModelIR {
    if (!this.timeModel) {
      throw new Error('Time model not set');
    }
    return this.timeModel;
  }
}

// =============================================================================
// Hash-consing utility functions (I13)
// =============================================================================
// JSON.stringify is sufficient because all expression fields are readonly primitives/arrays
// No circular references, no functions, deterministic order

function hashSigExpr(expr: SigExpr): string {
  return JSON.stringify(expr);
}

function hashFieldExpr(expr: FieldExpr): string {
  return JSON.stringify(expr);
}

function hashEventExpr(expr: EventExpr): string {
  return JSON.stringify(expr);
}

/**
 * Create a new IRBuilder instance.
 */
export function createIRBuilder(): IRBuilder {
  return new IRBuilderImpl();
}
