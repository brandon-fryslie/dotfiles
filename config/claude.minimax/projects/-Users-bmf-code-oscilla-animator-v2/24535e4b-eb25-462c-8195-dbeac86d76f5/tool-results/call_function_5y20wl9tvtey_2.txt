     1→# Sprint: const-value - ConstValue Discriminated Union
     2→Generated: 2026-01-28-192541
     3→Confidence: HIGH: 1, MEDIUM: 0, LOW: 0
     4→Status: READY FOR IMPLEMENTATION
     5→Source: EVALUATION-2026-01-28-191553.md
     6→Dependencies: Sprint 3 (authority-consolidation) - requires C-4 (axis enforcement)
     7→
     8→## Sprint Goal
     9→Replace loose `value: number | string | boolean` with strongly-typed ConstValue discriminated union keyed by payload kind, enforcing Invariant I5 (const literal shape matches payload).
    10→
    11→## Scope
    12→**Deliverables:**
    13→- Define ConstValue discriminated union (7 variants: float, int, bool, vec2, vec3, color, cameraProjection)
    14→- Replace value field in SigExprConst and FieldExprConst
    15→- Update 40+ const construction sites
    16→- Add constValueMatchesPayload validator
    17→- Integrate with axis enforcement pass (C-4)
    18→
    19→**Dependencies**: Requires Sprint 3 C-4 (axis enforcement pass to validate payload match)
    20→
    21→## Work Items
    22→
    23→### P0 (Critical): C-8 - ConstValue Discriminated Union
    24→
    25→**Dependencies**: Sprint 3 C-4 (axis enforcement validates ConstValue.kind matches payload.kind)
    26→**Spec Reference**: 00-exhaustive-type-system.md:275-293, 15-FiveAxesTypeSystem-Conclusion.md:95-99 • **Status Reference**: EVALUATION-2026-01-28-191553.md:212-244
    27→
    28→**Confidence**: HIGH (spec in 00-exhaustive-type-system.md is complete, no ambiguities)
    29→
    30→#### Description
    31→Replace `value: number | string | boolean` with strongly-typed ConstValue discriminated union in SigExprConst and FieldExprConst. This enforces Invariant I5: "Const literal shape matches payload." Currently you can construct `SigExprConst` with `value: "string"` and `type.payload.kind: 'float'`, causing runtime crashes in renderer (assumes value shape matches payload). ConstValue prevents this at compile time.
    32→
    33→**Current State**:
    34→- src/compiler/ir/types.ts:98 — SigExprConst uses `value: number | string | boolean`
    35→- src/compiler/ir/types.ts:225-230 — FieldExprConst uses same pattern
    36→- No ConstValue type exists
    37→- No payload-shape validation at construction sites
    38→- Runtime hazard: renderer assumes value shape matches payload, crash if wrong
    39→
    40→**Spec Contract** (00-exhaustive-type-system.md:275-293):
    41→```typescript
    42→export type ConstValue =
    43→  | { readonly kind: 'float'; readonly value: number }
    44→  | { readonly kind: 'int'; readonly value: number }
    45→  | { readonly kind: 'bool'; readonly value: boolean }
    46→  | { readonly kind: 'vec2'; readonly value: readonly [number, number] }
    47→  | { readonly kind: 'vec3'; readonly value: readonly [number, number, number] }
    48→  | { readonly kind: 'color'; readonly value: readonly [number, number, number, number] }
    49→  | { readonly kind: 'cameraProjection'; readonly value: string };
    50→
    51→export function constValueMatchesPayload(payload: PayloadType, v: ConstValue): boolean {
    52→  return payload.kind === v.kind;
    53→}
    54→```
    55→
    56→**Invariant I5** (15-FiveAxesTypeSystem-Conclusion.md:95-99):
    57→- Const literal representation must be payload-shaped, not "anything"
    58→- ConstValue.kind MUST match CanonicalType.payload.kind
    59→- Axis enforcement pass checks this invariant
    60→
    61→#### Acceptance Criteria (REQUIRED)
    62→- [ ] ConstValue discriminated union defined in canonical-types.ts or types.ts (7 variants)
    63→- [ ] constValueMatchesPayload(payload, value): boolean validator exists
    64→- [ ] SigExprConst.value type changed from `number | string | boolean` to `ConstValue`
    65→- [ ] FieldExprConst.value type changed from loose union to `ConstValue`
    66→- [ ] All 40+ const construction sites updated to use discriminated union
    67→- [ ] Axis enforcement pass (C-4) validates payload match (calls constValueMatchesPayload)
    68→- [ ] Tests verify: float const with float payload (valid)
    69→- [ ] Tests verify: vec2 const with vec2 payload (valid)
    70→- [ ] Tests verify: float const with vec2 payload (invalid — caught by axis enforcement)
    71→- [ ] Tests verify: string value with float payload (type error at compile time)
    72→- [ ] All tests pass
    73→- [ ] TypeScript compilation succeeds
    74→
    75→#### Technical Notes
    76→
    77→**Define ConstValue** (add to canonical-types.ts or types.ts):
    78→```typescript
    79→/**
    80→ * Strongly-typed constant value representation.
    81→ * 
    82→ * INVARIANT I5: ConstValue.kind MUST match CanonicalType.payload.kind
    83→ * This is enforced at:
    84→ * 1. Compile time: TypeScript prevents wrong value types
    85→ * 2. Runtime: Axis enforcement validates kind matches payload
    86→ * 
    87→ * Tuple values are readonly to prevent mutation (maintains immutability contract).
    88→ */
    89→export type ConstValue =
    90→  | { readonly kind: 'float'; readonly value: number }
    91→  | { readonly kind: 'int'; readonly value: number }
    92→  | { readonly kind: 'bool'; readonly value: boolean }
    93→  | { readonly kind: 'vec2'; readonly value: readonly [number, number] }
    94→  | { readonly kind: 'vec3'; readonly value: readonly [number, number, number] }
    95→  | { readonly kind: 'color'; readonly value: readonly [number, number, number, number] }
    96→  | { readonly kind: 'cameraProjection'; readonly value: string };
    97→
    98→/**
    99→ * Validate that ConstValue.kind matches PayloadType.kind.
   100→ * Used by axis enforcement pass to catch mismatches.
   101→ */
   102→export function constValueMatchesPayload(
   103→  payload: PayloadType,
   104→  constValue: ConstValue
   105→): boolean {
   106→  return payload.kind === constValue.kind;
   107→}
   108→```
   109→
   110→**Update SigExprConst** (types.ts:98):
   111→```typescript
   112→// BEFORE
   113→export interface SigExprConst {
   114→  readonly kind: 'const';
   115→  readonly type: CanonicalType;
   116→  readonly value: number | string | boolean;  // <-- WRONG
   117→}
   118→
   119→// AFTER
   120→export interface SigExprConst {
   121→  readonly kind: 'const';
   122→  readonly type: CanonicalType;
   123→  readonly value: ConstValue;  // <-- CORRECT
   124→}
   125→```
   126→
   127→**Update FieldExprConst** (types.ts:225-230):
   128→```typescript
   129→// BEFORE
   130→export interface FieldExprConst {
   131→  readonly kind: 'const';
   132→  readonly type: CanonicalType;
   133→  readonly value: number | string | boolean;  // <-- WRONG
   134→}
   135→
   136→// AFTER
   137→export interface FieldExprConst {
   138→  readonly kind: 'const';
   139→  readonly type: CanonicalType;
   140→  readonly value: ConstValue;  // <-- CORRECT
   141→}
   142→```
   143→
   144→**Construction pattern:**
   145→```typescript
   146→// BEFORE (type unsafe)
   147→const expr: SigExprConst = {
   148→  kind: 'const',
   149→  type: someFloatType,
   150→  value: "wrong"  // Compiles but causes runtime crash!
   151→};
   152→
   153→// AFTER (type safe)
   154→const expr: SigExprConst = {
   155→  kind: 'const',
   156→  type: someFloatType,
   157→  value: { kind: 'float', value: 42.0 }  // Must match payload.kind
   158→};
   159→
   160→// Vec2 example
   161→const expr: SigExprConst = {
   162→  kind: 'const',
   163→  type: someVec2Type,
   164→  value: { kind: 'vec2', value: [1.0, 2.0] as const }  // Tuple is readonly
   165→};
   166→
   167→// Bool example
   168→const expr: SigExprConst = {
   169→  kind: 'const',
   170→  type: someBoolType,
   171→  value: { kind: 'bool', value: true }
   172→};
   173→```
   174→
   175→**Axis enforcement integration** (add to axis-enforcement.ts from C-4):
   176→```typescript
   177→// In validateAxes function, add:
   178→
   179→// Check ConstValue matches payload
   180→for (const expr of findAllConstExpr(patch)) {
   181→  if (expr.kind === 'const' && !constValueMatchesPayload(expr.type.payload, expr.value)) {
   182→    diagnostics.push({
   183→      kind: 'AxisInvalid',
   184→      location: getExprLocation(expr),
   185→      reason: 'Const value kind must match payload kind',
   186→      expressionKind: expr.kind,
   187→      violation: `value.kind=${expr.value.kind}, payload.kind=${expr.type.payload.kind}`
   188→    });
   189→  }
   190→}
   191→```
   192→
   193→**Helper for constructing typed const values:**
   194→```typescript
   195→// Optional: Add helpers for common cases
   196→export function floatConst(value: number): ConstValue {
   197→  return { kind: 'float', value };
   198→}
   199→
   200→export function boolConst(value: boolean): ConstValue {
   201→  return { kind: 'bool', value };
   202→}
   203→
   204→export function vec2Const(x: number, y: number): ConstValue {
   205→  return { kind: 'vec2', value: [x, y] as const };
   206→}
   207→
   208→export function vec3Const(x: number, y: number, z: number): ConstValue {
   209→  return { kind: 'vec3', value: [x, y, z] as const };
   210→}
   211→```
   212→
   213→#### Construction Sites (estimate 40+)
   214→
   215→**Search commands:**
   216→```bash
   217→# Find SigExprConst construction sites
   218→grep -rn "kind: 'const'" src/ | grep Sig
   219→
   220→# Find FieldExprConst construction sites
   221→grep -rn "kind: 'const'" src/ | grep Field
   222→
   223→# Find direct value assignments
   224→grep -rn "value: [0-9]" src/ | grep -E "SigExpr|FieldExpr"
   225→```
   226→
   227→**Typical locations:**
   228→- src/compiler/ir-builder/ — IR builder creates const nodes
   229→- src/compiler/passes-v2/ — Normalization/optimization passes
   230→- src/__tests__/ — Test fixtures
   231→- src/runtime/ — If runtime creates const expressions
   232→
   233→**Migration strategy:**
   234→1. Define ConstValue type
   235→2. Update SigExprConst and FieldExprConst interfaces
   236→3. Run TypeScript compiler — it will identify ALL construction sites
   237→4. Update each site based on payload kind
   238→5. Add axis enforcement validation
   239→6. Run tests
   240→
   241→**TypeScript will find all sites:**
   242→```bash
   243→npm run typecheck 2>&1 | grep -E "SigExprConst|FieldExprConst|value"
   244→```
   245→
   246→#### Test Cases
   247→
   248→**Add to axis-enforcement.test.ts** (from C-4):
   249→```typescript
   250→describe('Axis Enforcement: ConstValue', () => {
   251→  test('Valid float const passes', () => {
   252→    const expr: SigExprConst = {
   253→      kind: 'const',
   254→      type: {
   255→        payload: { kind: 'float' },
   256→        unit: { kind: 'none' },
   257→        extent: { /* ... */ }
   258→      },
   259→      value: { kind: 'float', value: 42.0 }  // Matches payload
   260→    };
   261→    const patch: TypedPatch = { events: [], signals: [expr], fields: [] };
   262→
   263→    const diagnostics = validateAxes(patch);
   264→    expect(diagnostics).toHaveLength(0);
   265→  });
   266→
   267→  test('Valid vec2 const passes', () => {
   268→    const expr: SigExprConst = {
   269→      kind: 'const',
   270→      type: {
   271→        payload: { kind: 'vec2' },
   272→        unit: { kind: 'none' },
   273→        extent: { /* ... */ }
   274→      },
   275→      value: { kind: 'vec2', value: [1.0, 2.0] as const }  // Matches payload
   276→    };
   277→    const patch: TypedPatch = { events: [], signals: [expr], fields: [] };
   278→
   279→    const diagnostics = validateAxes(patch);
   280→    expect(diagnostics).toHaveLength(0);
   281→  });
   282→
   283→  test('Float const with vec2 payload fails', () => {
   284→    const expr: SigExprConst = {
   285→      kind: 'const',
   286→      type: {
   287→        payload: { kind: 'vec2' },  // Expects vec2
   288→        unit: { kind: 'none' },
   289→        extent: { /* ... */ }
   290→      },
   291→      value: { kind: 'float', value: 42.0 }  // MISMATCH
   292→    };
   293→    const patch: TypedPatch = { events: [], signals: [expr], fields: [] };
   294→
   295→    const diagnostics = validateAxes(patch);
   296→    expect(diagnostics).toHaveLength(1);
   297→    expect(diagnostics[0].kind).toBe('AxisInvalid');
   298→    expect(diagnostics[0].violation).toContain('value.kind=float, payload.kind=vec2');
   299→  });
   300→
   301→  test('Vec2 tuple is readonly (immutability)', () => {
   302→    const value: ConstValue = { kind: 'vec2', value: [1.0, 2.0] as const };
   303→    
   304→    // TypeScript should prevent mutation
   305→    // @ts-expect-error — readonly tuple
   306→    // value.value[0] = 99.0;
   307→    
   308→    expect(value.value).toEqual([1.0, 2.0]);
   309→  });
   310→
   311→  // Add tests for: int, bool, vec3, color, cameraProjection
   312→});
   313→```
   314→
   315→**Add to canonical-types.test.ts:**
   316→```typescript
   317→describe('constValueMatchesPayload', () => {
   318→  test('float value matches float payload', () => {
   319→    const payload: PayloadType = { kind: 'float' };
   320→    const value: ConstValue = { kind: 'float', value: 42.0 };
   321→    
   322→    expect(constValueMatchesPayload(payload, value)).toBe(true);
   323→  });
   324→
   325→  test('float value does not match vec2 payload', () => {
   326→    const payload: PayloadType = { kind: 'vec2' };
   327→    const value: ConstValue = { kind: 'float', value: 42.0 };
   328→    
   329→    expect(constValueMatchesPayload(payload, value)).toBe(false);
   330→  });
   331→
   332→  test('vec2 value matches vec2 payload', () => {
   333→    const payload: PayloadType = { kind: 'vec2' };
   334→    const value: ConstValue = { kind: 'vec2', value: [1.0, 2.0] as const };
   335→    
   336→    expect(constValueMatchesPayload(payload, value)).toBe(true);
   337→  });
   338→
   339→  // Add tests for all 7 ConstValue variants
   340→});
   341→```
   342→
   343→---
   344→
   345→## Dependencies
   346→- **REQUIRES Sprint 3 C-4**: Axis enforcement pass must exist to validate payload match
   347→- **COMPLETES**: CanonicalType migration (all 8 work items from gap analysis)
   348→
   349→## Risks
   350→- **Moderate Impact**: Touches 40+ const construction sites
   351→- **Mitigation**: TypeScript compiler identifies all sites, test suite validates correctness
   352→- **Low Risk**: Spec is complete and unambiguous
   353→
   354→---
   355→
   356→## Success Criteria
   357→- ✅ ConstValue discriminated union defined (7 variants)
   358→- ✅ constValueMatchesPayload validator exists
   359→- ✅ SigExprConst and FieldExprConst use ConstValue (not loose unions)
   360→- ✅ All 40+ construction sites updated
   361→- ✅ Axis enforcement validates ConstValue.kind matches payload.kind
   362→- ✅ Tests verify payload matching (positive + negative cases)
   363→- ✅ All tests pass
   364→- ✅ Zero TypeScript compilation errors
   365→- ✅ Runtime type safety: impossible to construct mismatched const values
   366→
   367→---
   368→
   369→## Estimated Effort
   370→- C-8 (ConstValue discriminated union): 6 hours
   371→  - Define type: 1 hour
   372→  - Update interfaces: 1 hour
   373→  - Update 40+ construction sites: 3 hours
   374→  - Tests + axis enforcement integration: 1 hour
   375→**Total: 6 hours**
   376→
   377→---
   378→
   379→## Definition of Done (CanonicalType Migration Complete)
   380→
   381→After this sprint, all 8 work items from gap analysis are complete:
   382→- ✅ C-1: EventExpr typed (Sprint 2)
   383→- ✅ C-2: core/ids.ts authority (Sprint 1)
   384→- ✅ C-3: reduce_field renamed (Sprint 1)
   385→- ✅ C-4: Axis enforcement (Sprint 3)
   386→- ✅ C-5: instanceId removed, getManyInstance added (Sprint 3)
   387→- ✅ C-6: string leakage fixed (Sprint 2)
   388→- ✅ C-7: FieldExprArray deleted (Sprint 1)
   389→- ✅ C-8: ConstValue discriminated union (Sprint 4) ← THIS SPRINT
   390→
   391→**Next Phase**: U-1 (ValueExpr IR) can safely start — axis enforcement ensures valid IR.
   392→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
